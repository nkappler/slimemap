/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/slimeMap.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/big-integer/BigInteger.js":
/*!************************************************!*\
  !*** ./node_modules/big-integer/BigInteger.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        LOG_MAX_INT = Math.log(MAX_INT);\r\n\r\n    function Integer(v, radix) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 ? parseValue(v) : parseBase(v, radix);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        var value = n.value;\r\n        if (value === 0) return false;\r\n        if (value === 1) return true;\r\n        if (value === 2) return this.isEven();\r\n        return this.mod(n).equals(Integer[0]);\r\n    };\r\n    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n    \r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2);\r\n        for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;\r\n            for (t = true, d = b; t && d.lesser(nPrev); d = d.multiply(2)) {\r\n                x = x.square().mod(n);\r\n                if (x.equals(nPrev)) t = false;\r\n            }\r\n            if (t) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    BigInteger.prototype.isPrime = function () {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        return millerRabinTest(this.abs(), [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);\r\n    };\r\n    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2)));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.equals(bigInt.zero)) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.equals(1)) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return ((typeof n === \"number\" || typeof n === \"string\") && +Math.abs(n) <= BASE) ||\r\n            (n instanceof BigInteger && n.value.length <= 1);\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (n) {\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (n) {\r\n        var remQuo;\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = Math.min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(Math.random() * range));\r\n        var length = range.value.length - 1;\r\n        var result = [], restricted = true;\r\n        for (var i = length; i >= 0; i--) {\r\n            var top = restricted ? range.value[i] : BASE;\r\n            var digit = truncate(Math.random() * top);\r\n            result.unshift(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        result = arrayToSmall(result);\r\n        return low.add(typeof result === \"number\" ? new SmallInteger(result) : new BigInteger(result, false));\r\n    }\r\n    var parseBase = function (text, base) {\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        for (var i = 0; i < length; i++) {\r\n            var c = text[i].toLowerCase();\r\n            if (c === \"-\") continue;\r\n            if (/[a-z0-9]/.test(c)) {\r\n                if (/[0-9]/.test(c) && +c >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                } else if (c.charCodeAt(0) - 87 >= absBase) {\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        if (2 <= base && base <= 36) {\r\n            if (length <= LOG_MAX_INT / Math.log(base)) {\r\n                var result = parseInt(text, base);\r\n                if (isNaN(result)) {\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n                return new SmallInteger(parseInt(text, base));\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i].toLowerCase(),\r\n                charCode = c.charCodeAt(0);\r\n            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));\r\n            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\");\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit) {\r\n        if (digit <= 35) {\r\n            return \"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(digit);\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(+n - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.equals(1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(+n))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(stringify).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix);\r\n        return String(this.value);\r\n    };\r\n    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = new SmallInteger(i);\r\n        if (i > 0) Integer[-i] = new SmallInteger(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n        return bigInt;\r\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/big-integer/BigInteger.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/seededRandom.ts":
/*!*****************************!*\
  !*** ./src/seededRandom.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar big_integer_1 = __importDefault(__webpack_require__(/*! ../node_modules/big-integer */ \"./node_modules/big-integer/BigInteger.js\"));\r\n/**\r\n * partial seededRandom as in Java\r\n */\r\nvar SeededRandom = /** @class */ (function () {\r\n    function SeededRandom(initseed) {\r\n        if (initseed === void 0) { initseed = Date.now(); }\r\n        this.seed = big_integer_1.default(initseed);\r\n        this.multiplier = big_integer_1.default(\"5DEECE66D\", 16);\r\n        this.addend = big_integer_1.default(\"B\", 16);\r\n        this.mask = big_integer_1.default(\"281474976710655\");\r\n        this.seed = this.initialScramble(this.seed);\r\n        this.seed = this.initialScramble(this.seed);\r\n    }\r\n    SeededRandom.prototype.initialScramble = function (seed) {\r\n        var temp = seed.xor(this.multiplier);\r\n        return temp.and(this.mask);\r\n    };\r\n    SeededRandom.prototype.setSeed = function (newseed) {\r\n        this.seed = this.initialScramble(newseed);\r\n    };\r\n    SeededRandom.prototype.next = function (bits) {\r\n        var oldseed = this.seed;\r\n        var nextseed = oldseed.multiply(this.multiplier).add(this.addend).and(this.mask);\r\n        this.seed = nextseed;\r\n        return Math.floor(nextseed.shiftRight((48 - bits)));\r\n    };\r\n    SeededRandom.prototype.nextInt = function (b) {\r\n        var bound = b;\r\n        if (bound <= 0) {\r\n            bound *= -1;\r\n        }\r\n        var r = this.next(31);\r\n        var m = bound - 1;\r\n        // tslint:disable-next-line:no-bitwise\r\n        if ((bound & m) === 0) { // i.e., bound is a power of 2 { {\r\n            // tslint:disable-next-line:no-bitwise\r\n            r = Math.floor((bound * r) >> 31);\r\n        }\r\n        else {\r\n            for (var u = r; \r\n            // tslint:disable-next-line:no-conditional-assignment\r\n            u - (r = u % bound) + m < 0; u = this.next(31)) { /**/ }\r\n        }\r\n        return r;\r\n    };\r\n    SeededRandom.prototype.getSeed = function () {\r\n        return this.seed;\r\n    };\r\n    return SeededRandom;\r\n}());\r\nexports.SeededRandom = SeededRandom;\r\n\n\n//# sourceURL=webpack:///./src/seededRandom.ts?");

/***/ }),

/***/ "./src/slimeMap.ts":
/*!*************************!*\
  !*** ./src/slimeMap.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// import * as bigInt from \"./BigInteger\";\r\nvar big_integer_1 = __importDefault(__webpack_require__(/*! ../node_modules/big-integer */ \"./node_modules/big-integer/BigInteger.js\"));\r\nvar seededRandom_1 = __webpack_require__(/*! ./seededRandom */ \"./src/seededRandom.ts\");\r\nvar SlimeM = /** @class */ (function () {\r\n    function SlimeM() {\r\n        this.seed = new seededRandom_1.SeededRandom();\r\n    }\r\n    return SlimeM;\r\n}());\r\nexports.SlimeM = SlimeM;\r\nvar SlimeMap = /** @class */ (function () {\r\n    function SlimeMap(id) {\r\n        var _this = this;\r\n        this.seed = big_integer_1.default(1234);\r\n        this.height = 0;\r\n        this.width = 0;\r\n        this.xPos = 0;\r\n        this.yPos = 0;\r\n        this.mousePos = new Array(2);\r\n        this.zoom = 2.5;\r\n        this.minzoom = 0.7;\r\n        this.maxzoom = 5;\r\n        this.chunkbuffer = 3;\r\n        this.borderleft = 70;\r\n        this.bordertop = 50;\r\n        this.borderbottom = 20;\r\n        this.borderright = 20;\r\n        this.grabbed = false;\r\n        this.grabbedCoord = new Array(2);\r\n        this.ctx = null;\r\n        this.canvas = document.getElementById(id);\r\n        this.initCanvas(id);\r\n        this.update();\r\n        this.drawStaticUI();\r\n        this.vp = this.viewport();\r\n        this.chunkvp = this.chunkviewport();\r\n        this.initSlimeChunks();\r\n        this.redraw();\r\n        this.canvas.onmousemove = function (event) {\r\n            _this.mousePos[0] = event.layerX;\r\n            _this.mousePos[1] = event.layerY;\r\n            _this.onMouseMove();\r\n        };\r\n        this.canvas.onmousedown = function (event) {\r\n            var vec = _this.getMapCoord(_this.mousePos);\r\n            if (vec) {\r\n                _this.grabbed = true;\r\n                _this.canvas.setAttribute(\"style\", \"cursor: grabbing; cursor: -webkit-grabbing\");\r\n                _this.grabbedCoord = vec;\r\n            }\r\n        };\r\n        this.canvas.onmouseup = function (event) {\r\n            _this.canvas.setAttribute(\"style\", \"cursor: grab; cursor: -webkit-grab\");\r\n            _this.grabbed = false;\r\n        };\r\n    }\r\n    SlimeMap.prototype.initCanvas = function (id) {\r\n        if (this.canvas.getContext) {\r\n            this.ctx = this.canvas.getContext('2d');\r\n        }\r\n        else {\r\n            alert(\"Dein Browser unterstützt diese Funktion noch nicht.\\nBitte installiere die neueste Version von deinem Browser.\");\r\n        }\r\n        this.assertEventHandlers();\r\n    };\r\n    SlimeMap.prototype.assertEventHandlers = function () {\r\n        var _this = this;\r\n        var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? \"DOMMouseScroll\" : \"mousewheel\"; //FF doesn't recognize mousewheel as of FF3.x\r\n        var evt = function (e) { return _this.onscroll(e); };\r\n        if (this.canvas.attachEvent) { //if IE (and Opera depending on user setting)\r\n            this.canvas.attachEvent(\"on\" + mousewheelevt, evt);\r\n        }\r\n        else if (this.canvas.addEventListener) { //WC3 browsers\r\n            this.canvas.addEventListener(mousewheelevt, evt, false);\r\n        }\r\n    };\r\n    SlimeMap.prototype.onscroll = function (event) {\r\n        if (this.getMapCoord(this.mousePos)) {\r\n            event.preventDefault();\r\n            var zoomfactor = 0.2;\r\n            if (this.zoom < 2) {\r\n                zoomfactor /= 2;\r\n            }\r\n            if (event.wheelDelta < 0) {\r\n                zoomfactor *= -1;\r\n            }\r\n            else if (event.detail < 0) {\r\n                zoomfactor *= -1;\r\n            }\r\n            if ((this.zoom + zoomfactor) >= this.minzoom && (this.zoom + zoomfactor) <= this.maxzoom) {\r\n                this.zoom += zoomfactor;\r\n                this.redraw();\r\n            }\r\n            this.onMouseMove();\r\n        }\r\n    };\r\n    SlimeMap.prototype.chunkviewport = function () {\r\n        var v = new Array(4);\r\n        v[0] = Math.ceil(this.vp[0] / 16) - this.chunkbuffer;\r\n        v[1] = Math.ceil(this.vp[1] / 16) - this.chunkbuffer;\r\n        v[2] = Math.ceil(this.vp[2] / 16) + this.chunkbuffer;\r\n        v[3] = Math.ceil(this.vp[3] / 16) + this.chunkbuffer;\r\n        return v;\r\n    };\r\n    SlimeMap.prototype.isSlimeChunk = function (vec) {\r\n        var xPos = vec[0];\r\n        var zPos = vec[1];\r\n        var tempseed = big_integer_1.default(\"4987142\").multiply(xPos).multiply(xPos);\r\n        tempseed = tempseed.add(big_integer_1.default(\"5947611\").multiply(xPos));\r\n        tempseed = tempseed.add(big_integer_1.default(\"4392871\").multiply(zPos).multiply(zPos));\r\n        tempseed = tempseed.add(big_integer_1.default(\"389711\").multiply(zPos));\r\n        tempseed = this.seed.add(tempseed);\r\n        tempseed = tempseed.xor(big_integer_1.default(\"987234911\"));\r\n        var rnd = new seededRandom_1.SeededRandom(tempseed.toString());\r\n        return (rnd.nextInt(10) === 0);\r\n        //see http://minecraft-de.gamepedia.com/Schleim?cookieSetup=true#Spawning_in_speziellen_Chunks\r\n    };\r\n    SlimeMap.prototype.update = function () {\r\n        if (!this.ctx) {\r\n            return;\r\n        }\r\n        this.vp = this.viewport();\r\n        this.width = this.canvas.width;\r\n        this.height = this.canvas.height;\r\n    };\r\n    SlimeMap.prototype.onMouseMove = function () {\r\n        this.clearfooter();\r\n        var vec = this.getMapCoord(this.mousePos);\r\n        if (vec) {\r\n            if (this.grabbed) {\r\n                this.canvas.setAttribute(\"style\", \"cursor: grabbing; cursor: -webkit-grabbing\");\r\n                var offsetX = this.grabbedCoord[0] - this.xPos;\r\n                var offsetY = this.grabbedCoord[1] - this.yPos;\r\n                this.xPos = vec[0] - offsetX;\r\n                this.yPos = vec[1] - offsetY;\r\n                this.redraw();\r\n            }\r\n            else if (this.ctx) {\r\n                this.canvas.setAttribute(\"style\", \"cursor: grab; cursor: -webkit-grab\");\r\n                this.ctx.font = \"15px MyriadPro\";\r\n                this.ctx.fillStyle = \"#000000\";\r\n                this.ctx.fillText(\"X: \" + vec[0].toFixed(1) + \"    Z: \" + vec[1].toFixed(1), this.borderleft, this.height - this.borderbottom + 15);\r\n                var Chunk = new Array(2);\r\n                Chunk[0] = Math.floor(vec[0] / 16);\r\n                Chunk[1] = Math.floor(vec[1] / 16);\r\n                var Slimes = (this.slimechunks[\"[\" + Chunk[0] + \",\" + Chunk[1] + \"]\"]) ? \"ja\" : \"nein\";\r\n                this.ctx.fillText(\"Slimes: \" + Slimes, this.borderleft + 200, this.height - this.borderbottom + 15);\r\n                var From = new Array(2);\r\n                From[0] = Chunk[0] * 16;\r\n                From[1] = Chunk[1] * 16;\r\n                var To = new Array(2);\r\n                To[0] = (Chunk[0] + 1) * 16 - 1;\r\n                To[1] = (Chunk[1] + 1) * 16 - 1;\r\n                this.ctx.textAlign = \"end\";\r\n                this.ctx.fillText(\"Chunk: ( \" + Chunk[0] + \" / \" + Chunk[1] + \" )  im Bereich von: ( \" +\r\n                    From[0] + \" / \" + From[1] + \")  bis: ( \" +\r\n                    To[0] + \" / \" + To[1] + \" )\", this.width - this.borderright, this.height - this.borderbottom + 15);\r\n                this.ctx.textAlign = \"start\";\r\n            }\r\n        }\r\n        else {\r\n            this.canvas.setAttribute(\"style\", \"cursor: default\");\r\n        }\r\n    };\r\n    SlimeMap.prototype.clearfooter = function () {\r\n        if (this.ctx) {\r\n            this.ctx.fillStyle = \"#CED4DE\";\r\n            this.ctx.fillRect(this.borderleft, this.height - this.borderbottom, this.width - this.borderleft, this.borderbottom);\r\n        }\r\n    };\r\n    SlimeMap.prototype.redraw = function () {\r\n        this.vp = this.viewport();\r\n        if (!this.ctx) {\r\n            return;\r\n        }\r\n        //fill map\r\n        this.ctx.fillStyle = \"#e0e0e0\";\r\n        var p1 = new Array(2);\r\n        var p2 = new Array(2);\r\n        p1[0] = this.vp[0];\r\n        p1[1] = this.vp[1];\r\n        p2[0] = this.vp[2];\r\n        p2[1] = this.vp[3];\r\n        p1 = this.getAbsCoord(p1);\r\n        p2 = this.getAbsCoord(p2);\r\n        this.ctx.fillRect(p1[0], p1[1], p2[0] - p1[0], p2[1] - p1[1]);\r\n        //UI\r\n        this.drawUI();\r\n        this.drawAxes();\r\n        this.drawSlimeChunks();\r\n        this.clearBorderRight();\r\n        this.clearfooter();\r\n        this.recalcSlimeChunks();\r\n    };\r\n    SlimeMap.prototype.recalcSlimeChunks = function () {\r\n        if (JSON.stringify(this.chunkvp) !== JSON.stringify(this.chunkviewport())) {\r\n            var newChunkvp = this.chunkviewport();\r\n            var top_1 = this.chunkvp[1] - newChunkvp[1];\r\n            var bottom = newChunkvp[3] - this.chunkvp[3];\r\n            var left = this.chunkvp[0] - newChunkvp[0];\r\n            var right = newChunkvp[2] - this.chunkvp[2];\r\n            if (top_1 > 0) {\r\n                for (var i = 1; i <= top_1; i++) {\r\n                    //addRow( chunkvp[1] - i );\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i > top_1; i--) {\r\n                    this.removeRow(this.chunkvp[1] - i);\r\n                }\r\n            }\r\n            if (bottom > 0) {\r\n                for (var i = 1; i <= bottom; i++) {\r\n                    //addRow( chunkvp[3] + i );\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i > bottom; i--) {\r\n                    this.removeRow(this.chunkvp[3] + i);\r\n                }\r\n            }\r\n            if (left > 0) {\r\n                for (var i = 1; i <= left; i++) {\r\n                    //addColumn( chunkvp[0] - i );\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i > left; i--) {\r\n                    this.removeColumn(this.chunkvp[0] - i);\r\n                }\r\n            }\r\n            if (right > 0) {\r\n                for (var i = 1; i <= right; i++) {\r\n                    //addColumn( chunkvp[2] + i );\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i > right; i--) {\r\n                    this.removeColumn(this.chunkvp[2] + i);\r\n                }\r\n            }\r\n            this.chunkvp = newChunkvp;\r\n        }\r\n    };\r\n    SlimeMap.prototype.addRow = function (row) {\r\n        var Cols = Math.abs(this.chunkvp[1]) + Math.abs(this.chunkvp[3]);\r\n        for (var i = 0; i < Cols; i++) {\r\n            var mapChunkPos = this.getMapChunkPos(new Array(i, 0));\r\n            var isSC = this.isSlimeChunk(new Array(mapChunkPos[0], row));\r\n            var hash = JSON.stringify(mapChunkPos);\r\n            this.slimechunks[hash] = isSC;\r\n        }\r\n    };\r\n    SlimeMap.prototype.removeRow = function (row) {\r\n        var keys = Object.keys(this.slimechunks);\r\n        // tslint:disable-next-line:prefer-for-of\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            if (key.indexOf(\",\" + row + \"]\") !== -1) {\r\n                delete this.slimechunks[key];\r\n            }\r\n        }\r\n    };\r\n    SlimeMap.prototype.addColumn = function (col) {\r\n        var Rows = Math.abs(this.chunkvp[0]) + Math.abs(this.chunkvp[2]);\r\n        for (var i = 0; i < Rows; i++) {\r\n            var mapChunkPos = this.getMapChunkPos(new Array(0, i));\r\n            var isSC = this.isSlimeChunk(new Array(col, mapChunkPos[1]));\r\n            var hash = JSON.stringify(mapChunkPos);\r\n            this.slimechunks[hash] = isSC;\r\n        }\r\n    };\r\n    SlimeMap.prototype.removeColumn = function (col) {\r\n        var keys = Object.keys(this.slimechunks);\r\n        // tslint:disable-next-line:prefer-for-of\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            if (key.indexOf(\"[\" + col + \",\") !== -1) {\r\n                delete this.slimechunks[key];\r\n            }\r\n        }\r\n    };\r\n    SlimeMap.prototype.initSlimeChunks = function () {\r\n        var ChunksCountX = Math.abs(this.chunkvp[0]) + Math.abs(this.chunkvp[2]);\r\n        var ChunksCountZ = Math.abs(this.chunkvp[1]) + Math.abs(this.chunkvp[3]);\r\n        this.slimechunks = new Object({});\r\n        for (var i = 0; i < ChunksCountX; i++) {\r\n            for (var j = 0; j < ChunksCountZ; j++) {\r\n                var mapChunkPos = this.getMapChunkPos(new Array(i, j));\r\n                var isSC = this.isSlimeChunk(mapChunkPos);\r\n                var hash = JSON.stringify(mapChunkPos);\r\n                this.slimechunks[hash] = isSC;\r\n            }\r\n        }\r\n    };\r\n    SlimeMap.prototype.getMapChunkPos = function (vec) {\r\n        vec[0] += this.chunkvp[0];\r\n        vec[1] += this.chunkvp[1];\r\n        return vec;\r\n    };\r\n    SlimeMap.prototype.drawSlimeChunks = function () {\r\n        if (!this.ctx) {\r\n            return;\r\n        }\r\n        this.ctx.fillStyle = \"#44dd55\";\r\n        var ChunksCountX = Math.abs(this.chunkvp[0]) + Math.abs(this.chunkvp[2]);\r\n        var ChunksCountZ = Math.abs(this.chunkvp[1]) + Math.abs(this.chunkvp[3]);\r\n        for (var i = 0; i < ChunksCountX; i++) {\r\n            for (var j = 0; j < ChunksCountZ; j++) {\r\n                var mapChunkPos = this.getMapChunkPos(new Array(i, j));\r\n                var key = JSON.stringify(mapChunkPos);\r\n                if (this.slimechunks[key] === undefined) {\r\n                    this.slimechunks[key] = this.isSlimeChunk(mapChunkPos);\r\n                }\r\n                if (this.slimechunks[key]) {\r\n                    var vec = mapChunkPos;\r\n                    vec[0] *= 16;\r\n                    vec[1] *= 16;\r\n                    var vec2 = this.getAbsCoord(vec);\r\n                    if (vec2) {\r\n                        this.ctx.fillRect(vec2[0] + 1, vec2[1] + 1, 16 * this.zoom - 2, 16 * this.zoom - 2);\r\n                    }\r\n                    else {\r\n                        vec2 = this.getAbsCoord(vec, true);\r\n                        var x = vec2[0] + 1;\r\n                        var z = vec2[1] + 1;\r\n                        var width = (16 * this.zoom) - 2;\r\n                        var height = (16 * this.zoom) - 2;\r\n                        var paint = false;\r\n                        if (x < this.borderleft && x + width >= this.borderleft) {\r\n                            width += x - this.borderleft;\r\n                            x = this.borderleft;\r\n                            paint = true;\r\n                        }\r\n                        if (z < this.bordertop && z + height >= this.bordertop) {\r\n                            height += z - this.bordertop;\r\n                            z = this.bordertop;\r\n                            paint = true;\r\n                        }\r\n                        if (x + width < this.borderleft || z + height < this.bordertop) {\r\n                            paint = false;\r\n                        }\r\n                        if (paint) {\r\n                            this.ctx.fillRect(x, z, width, height);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    SlimeMap.prototype.drawUI = function () {\r\n        if (!this.ctx) {\r\n            return;\r\n        }\r\n        this.clearAxes();\r\n        var factor = 16;\r\n        if (this.zoom < 2) {\r\n            factor *= 2;\r\n        }\r\n        if (this.zoom < 0.9) {\r\n            factor *= 2;\r\n        }\r\n        this.ctx.font = \"12px MyriadPro\";\r\n        this.ctx.fillStyle = \"#000000\";\r\n        //X\r\n        for (var i = Math.ceil(this.vp[0] / factor); i <= Math.floor(this.vp[2] / factor); i++) {\r\n            var mark = i * factor;\r\n            var pos = new Array(mark, this.vp[1]);\r\n            pos = this.getAbsCoord(pos);\r\n            this.ctx.fillText(mark, pos[0] - (mark.toString().length * 3), this.bordertop - 5);\r\n        }\r\n        //Z\r\n        for (var i = Math.ceil(this.vp[1] / factor); i <= Math.floor(this.vp[3] / factor); i++) {\r\n            var mark = i * factor;\r\n            var pos = new Array(this.vp[0], mark);\r\n            pos = this.getAbsCoord(pos);\r\n            this.ctx.fillText(mark, this.borderleft - 30, pos[1] + 4);\r\n        }\r\n    };\r\n    SlimeMap.prototype.drawStaticUI = function () {\r\n        if (!this.ctx) {\r\n            return;\r\n        }\r\n        //clear;\r\n        this.ctx.fillStyle = \"#CED4DE\";\r\n        this.ctx.fillRect(0, 0, this.width, this.height);\r\n        //Border\r\n        this.ctx.lineWidth = 1;\r\n        this.ctx.beginPath();\r\n        this.ctx.fillStyle = \"#000000\";\r\n        this.ctx.strokeStyle = \"#000000\";\r\n        this.ctx.moveTo(this.width - this.borderright, this.bordertop - 1);\r\n        this.ctx.lineTo(this.borderleft - 1, this.bordertop - 1);\r\n        this.ctx.lineTo(this.borderleft - 1, this.height - this.borderbottom);\r\n        this.ctx.stroke();\r\n        this.ctx.closePath();\r\n        this.ctx.strokeStyle = \"#333333\";\r\n        this.ctx.fillStyle = \"#333333\";\r\n        //North\r\n        this.ctx.lineWidth = 0.7;\r\n        this.ctx.moveTo(15, 5);\r\n        this.ctx.lineTo(5, 30);\r\n        this.ctx.lineTo(15, 20);\r\n        this.ctx.stroke();\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(15, 20);\r\n        this.ctx.lineTo(25, 30);\r\n        this.ctx.lineTo(15, 5);\r\n        this.ctx.fill();\r\n        this.ctx.stroke();\r\n        this.ctx.closePath();\r\n        this.ctx.font = \"15px MyriadPro\";\r\n        this.ctx.fillText(\"N\", 10, 40);\r\n        this.ctx.fillText(\"Seed: \" + this.seed.toString(), 40, 20);\r\n        //Axisnames\r\n        //X\r\n        this.ctx.font = \"20px MyriadPro\";\r\n        var mapwidthcenter = this.borderleft + ((this.width - this.borderleft - this.borderright) / 2);\r\n        this.ctx.fillText(\"X\", mapwidthcenter - 10, 20);\r\n        this.ctx.lineWidth = 0.4;\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(mapwidthcenter + 5, 13);\r\n        this.ctx.lineTo(mapwidthcenter + 17, 13);\r\n        this.ctx.lineTo(mapwidthcenter + 14, 10);\r\n        this.ctx.stroke();\r\n        this.ctx.moveTo(mapwidthcenter + 17, 13);\r\n        this.ctx.lineTo(mapwidthcenter + 14, 16);\r\n        this.ctx.stroke();\r\n        this.ctx.closePath();\r\n        //Z\r\n        var mapheightcenter = this.bordertop + ((this.height - this.bordertop - this.borderbottom) / 2);\r\n        this.ctx.fillText(\"Z\", 7.5, mapheightcenter - 5);\r\n        this.ctx.lineWidth = 0.4;\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(13, mapheightcenter);\r\n        this.ctx.lineTo(13, mapheightcenter + 12);\r\n        this.ctx.lineTo(10, mapheightcenter + 9);\r\n        this.ctx.stroke();\r\n        this.ctx.moveTo(13, mapheightcenter + 12);\r\n        this.ctx.lineTo(16, mapheightcenter + 9);\r\n        this.ctx.stroke();\r\n        this.ctx.closePath();\r\n    };\r\n    SlimeMap.prototype.drawAxes = function () {\r\n        if (!this.ctx) {\r\n            return;\r\n        }\r\n        var factor = 16;\r\n        this.ctx.strokeStyle = \"#000000\";\r\n        //X\r\n        for (var i = Math.ceil(this.vp[0] / factor); i <= Math.floor(this.vp[2] / factor); i++) {\r\n            // tslint:disable-next-line:prefer-conditional-expression\r\n            if (i === 0) {\r\n                this.ctx.lineWidth = 0.8;\r\n            }\r\n            else {\r\n                this.ctx.lineWidth = 0.5;\r\n            }\r\n            var mark = i * factor;\r\n            var pos = new Array(mark, this.vp[1]);\r\n            pos = this.getAbsCoord(pos);\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(pos[0], this.bordertop);\r\n            this.ctx.lineTo(pos[0], this.height - this.borderbottom);\r\n            this.ctx.stroke();\r\n            this.ctx.closePath();\r\n        }\r\n        //Z\r\n        for (var i = Math.ceil(this.vp[1] / factor); i <= Math.floor(this.vp[3] / factor); i++) {\r\n            // tslint:disable-next-line:prefer-conditional-expression\r\n            if (i === 0) {\r\n                this.ctx.lineWidth = 0.8;\r\n            }\r\n            else {\r\n                this.ctx.lineWidth = 0.5;\r\n            }\r\n            var mark = i * factor;\r\n            var pos = new Array(this.vp[0], mark);\r\n            pos = this.getAbsCoord(pos);\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(this.borderleft, pos[1]);\r\n            this.ctx.lineTo(this.width - this.borderright, pos[1]);\r\n            this.ctx.stroke();\r\n            this.ctx.closePath();\r\n        }\r\n    };\r\n    SlimeMap.prototype.clearAxes = function () {\r\n        if (!this.ctx) {\r\n            return;\r\n        }\r\n        this.ctx.fillStyle = \"#CED4DE\";\r\n        this.ctx.fillRect(30, this.bordertop - 22, this.width - 30, 20);\r\n        this.ctx.fillRect(this.borderleft - 32, 40, 30, this.height - 40);\r\n    };\r\n    SlimeMap.prototype.clearBorderRight = function () {\r\n        if (!this.ctx) {\r\n            return;\r\n        }\r\n        this.ctx.fillStyle = \"#CED4DE\";\r\n        this.ctx.fillRect(this.width - this.borderright, 0, this.borderright, this.height);\r\n    };\r\n    SlimeMap.prototype.isInVP = function (vec) {\r\n        return (vec[0] >= this.vp[0] && vec[0] <= this.vp[2] &&\r\n            vec[1] >= this.vp[1] && vec[1] <= this.vp[3]);\r\n    };\r\n    SlimeMap.prototype.isOverMap = function (vec) {\r\n        return (vec[0] >= this.borderleft && vec[0] <= (this.width - this.borderright) &&\r\n            vec[1] >= this.bordertop && vec[1] <= (this.height - this.borderbottom));\r\n    };\r\n    SlimeMap.prototype.getAbsCoord = function (vec, ignoreBorder) {\r\n        if (this.isInVP(vec) || ignoreBorder) {\r\n            var vec2 = new Array(2);\r\n            vec2[0] = ((Math.floor(vec[0]) - this.vp[0]) * this.zoom) + this.borderleft;\r\n            vec2[1] = ((Math.floor(vec[1]) - this.vp[1]) * this.zoom) + this.bordertop;\r\n            return vec2;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    SlimeMap.prototype.getMapCoord = function (vec) {\r\n        if (this.isOverMap(vec)) {\r\n            var vec2 = new Array(2);\r\n            vec2[0] = (vec[0] - this.borderleft) / this.zoom;\r\n            vec2[1] = (vec[1] - this.bordertop) / this.zoom;\r\n            vec2[0] += this.vp[0];\r\n            vec2[1] += this.vp[1];\r\n            return vec2;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    SlimeMap.prototype.viewport = function () {\r\n        var v = new Array(4);\r\n        var totalwidth = (this.width - this.borderleft) - this.borderright;\r\n        var totalheight = this.height - this.bordertop - this.borderbottom;\r\n        v[0] = -(Math.ceil((this.xPos + (totalwidth / 2)) / this.zoom));\r\n        v[1] = -(Math.ceil((this.yPos + (totalheight / 2)) / this.zoom));\r\n        v[2] = -(Math.floor((this.xPos - (totalwidth / 2)) / this.zoom));\r\n        v[3] = -(Math.floor((this.yPos - (totalheight / 2)) / this.zoom));\r\n        return v;\r\n    };\r\n    return SlimeMap;\r\n}());\r\nexports.SlimeMap = SlimeMap;\r\nfunction onload() {\r\n    if (document.readyState === \"interactive\") {\r\n        var sm = new SlimeMap(\"slimemap-canvas\");\r\n    }\r\n}\r\ndocument.onreadystatechange = onload;\r\n\n\n//# sourceURL=webpack:///./src/slimeMap.ts?");

/***/ })

/******/ });